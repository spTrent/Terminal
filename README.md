# Лабораторная работа №2

# Мини-оболочка с файловыми командами на Python

## Описание

Мини-оболочка, реализующая основные команды управления файлами и каталогами средствами Python: просмотр, копирование, перемещение, удаление, работа с архивами (zip/tar), история команд, undo и поиск по содержимому

---

## Установка:

    git clone https://github.com/spTrent/Terminal.git
    cd Terminal
---

## Запуск:

Для Linux:

    python3 -m src.main 

Для Windows:

    python -m src.main


Для Linux разделитель `/`

Для Windows разделитель `\\`

---

## Реализовано:

| Команда | Синтаксис | Описание |
|---------|-----------|----------|
| `ls` | `ls [-l[a]] [path]*` | Вывод содержимого директории |
| `cd` | `cd <path>` | Переход в указанный каталог |
| `cat` | `cat <file>+` | Вывод содержимого файлов |
| `cp` | `cp [-r] <src> <dest>` | Копирование файлов и директорий |
| `mv` | `mv <src>+ <dest>` | Перемещение/переименование файлов и директорий|
| `rm` | `rm [-r] <path>+` | Удаление файлов и директорий |
| `mkdir` | `mkdir <dir>+` | Создание директорий |
| `touch` | `touch <file>+` | Создание пустых файлов |
| `grep` | `grep [-r[i]] [pattern] [path]` | Поиск по содержимому файлов |
| `zip` | `zip <src> <archive>` | Архивирование в ZIP |
| `tar` | `tar <src> <archive>` | Архивирование в TAR.GZ |
| `unzip` | `unzip <archive>` | Распаковка ZIP-архива |
| `untar` | `untar <archive>` | Распаковка TAR-архива |
| `history` | `history [N]` | История ввода пользователя |
| `undo` | `undo` | Отмена последней операции cp/mv/rm |

**Обозначения:**
- `<...>` - обязательный аргумент
- `[...]` - необязательный аргумент или флаг
- `*` - сколько угодно
- `+` - хотя бы один

---


## Чему научился:

- Освоил работу с файловой системой средствами Python (`os`, `shutil`)
- Освоил логирование средствами `logging`

---

## Используемые библиотеки:

| Название | Применение |
|----------|------------|
| `os`, `shutil` | Работа с файловой системой |
| `logging` | Логирование |
| `re` | Поиск по содержимому |
| `datetime` | Форматирование времени для логирования |

---

## Алгоритм выполнения программы

1. **Запуск main.py**: Пользователь видит приглашение к вводу команд
2. **Парсинг команды**: Токенизация строки на команду, флаги и аргументы
3. **Выполнение команды**: Вызов соответствующего модуля
4. **Логирование**: Каждая команда и ошибка записываются в `shell.log`
5. **Завершение работы**: Сохранение истории и лога, удаление корзины

---

## Алгоритмы работы команд:

### 1. `ls [-l[a]] [path]*`

**Алгоритм:**
1. Получить флаги и пути из пользовательского ввода
2. Проверить корректность флага
3. Если путь не указан, использовать текущую директорию
4. Нормализовать путь
5. Проверить, что путь является директорией
6. Если флаг `-l` не указан:
    - Получить имена файлов в директории
7. Если флаг `-l` указан:
    - Получить имена файлов в директории
    - Для каждого файла получить данные
    - Извлечь: размер, время модификации, права доступа
    - Вывести в формате: `имя размер дата права`
8. Логировать команду в `shell.log`

---

### 2. `cd <path>`

**Алгоритм:**
1. Получить флаги и пути из пользовательского ввода
2. Проверить отсутствие флагов
3. Проверить, что указан ровно один путь
4. Нормализовать путь
5. Проверить, что путь существует и является директорией
6. Сменить рабочую директорию
7. Логировать команду
8. При ошибке — вывести сообщение и залогировать

---

### 3. `cat <file>+`

**Алгоритм:**
1. Получить флаги и пути из пользовательского ввода
2. Проверить отсутствие флагов
3. Проверить, что указан хотя бы один файл
4. Для каждого файла:
    - Нормализовать путь
    - Проверить, что путь является файлом
    - Открыть файл

    Если открылся:
      - Прочитать содержимое
      - Напечатать содержимое

    Если не открылся:
      - Обработать `UnicodeDecodeError`:
      - Вывести сообщение о невозможности прочтения
      - Залогировать ошибку
5. Логировать команду

---

### 4. `cp [-r] <src> <dest>`

**Алгоритм:**
1. Получить флаги и пути из пользовательского ввода
2. Проверить корректность флагов
3. Нормализовать исходный путь
4. Определить целевой путь
5. Проверить, что целевой путь не существует
6. Если флаг `-r` указан:
    - Проверить, что исходный путь - директория
7. Если флаг `-r` не указан:
    - Проверить, что исходный путь — файл
8. Скопировать
9. Добавить успешные операцию в `FOR_UNDO_HISTORY`
10. Логировать команду
11. При ошибке прав — залогировать, не добавлять в undo

---

### 5. `mv <src>+ <dest>`

**Алгоритм:**
1. Получить флаги и пути из пользовательского ввода
2. Проверить отсутствие флагов
3. Последний элемент paths — это dest, остальные — источники
4. Для каждого источника:
    - Нормализовать путь
    - Определить целевой путь
    - Переместить
    - Обработать исключения
5. Добавить успешные операции в `FOR_UNDO_HISTORY`
6. Логировать команду

---

### 6. `rm [-r] <path>+`

**Алгоритм:**
1. Получить флаги и пути из пользовательского ввода
2. Проверить корректность флагов
3. Проверить, что указан хотя бы один путь
4. Для каждого пути:
    - Нормализовать путь
    - Определить путь в корзине
    - Если флаг `-r` указан:
      - Проверить, что путь - директория
      - Запросить подтверждение
      - Если подтверждено:
        - Очистить корзину от файла с таким именем
        - Скопировать директорию в корзину
        - Удалить оригинал
    - Если флаг `-r` не указан:
      - Проверить, что путь - файл
      - Очистить корзину от файла с таким именем
      - Скопировать в корзину
      - Удалить оригинал через
5. Добавить успешные операции в `FOR_UNDO_HISTORY`
6. Логировать команду

---

### 7. `mkdir <dir>+`

**Алгоритм:**
1. Получить флаги и пути из пользовательского ввода
2. Проверить отсутствие флагов
3. Для каждого пути:
    - Проверить, существует ли директория
    - Если существует: Вывести сообщение, залогировать, пропустить
    - Если не существует: Создать
4. Логировать команду

---

### 8. `touch <file>+`

**Алгоритм:**
1. Получить флаги и пути из пользовательского ввода
2. Проверить отсутствие флагов
3. Для каждого пути:
    - Проверить, существует ли файл
    - Если существует: Вывести сообщение, залогировать, пропустить
    - Если не существует: Создать
4. Логировать команду

---

### 9. `grep [-r[i]] [pattern] [path]*`

**Алгоритм:**
1. Получить флаги и пути из пользовательского ввода
2. Проверить корректность флагов
3. Определить паттерн
4. Собрать список файлов для поиска
5. Для каждого файла:
    - Попытаться скомпилировать как regex
    - Если успешно: воспринимать как regex
    - Если не успешно: воспринимать как обычную подстроку
    - При флаге `-i` привести к нижнему регистру
    - Вывести строки, содержащие паттерн
6. Логировать команду

---

### 10. `zip/tar <folder> <archive>`

**Алгоритм:**
1. Получить флаги и пути из пользовательского ввода
2. Проверить отсутствие флагов
3. Проверить, что указано ровно 2 пути
4. Нормализовать путь к директории
5. Проверить, что путь - директория
6. Определить целевой путь архива
7. Создать архив
8. Логировать команду

---

### 11. `unzip/untar <archive>`

**Алгоритм:**
1. Получить флаги и пути из пользовательского ввода
2. Проверить отсутствие флагов
3. Проверить, что указан ровно 1 путь
4. Нормализовать путь
5. Проверить, что файл - архив
6. Извлечь имя архива
7. Определить целевую директорию
8. Проверить, что целевая директория не существует
9. Распаковать
10. Логировать команду

---

### 12. `history [N]`

**Алгоритм:**
1. Получить флаги и пути из пользовательского ввода
2. Проверить отсутствие флагов
3. Проверить, что указано не более 1 аргумента
4. Определить N:
    - Если аргумент указан: преобразовать в int
    - Иначе: N = 0 (вся история)
5. Открыть файл истории
6. Прочитать все строки
7. Вывести последние N строк
8. Логировать команду

---

### 13. undo

**Алгоритм:**
1. Получить флаги и пути из пользовательского ввода
2. Проверить, что `FOR_UNDO_HISTORY` не пуст
3. Извлечь последнюю запись
4. Отменить действие:
    - Для cp: удалить скопированный файл/директорию
    - Для mv: переместить файлы обратно (из dest в src)
    - Для rm: восстановить из корзины
5. Удалить запись из `FOR_UNDO_HISTORY`
6. Логировать команду
7. При ошибке логировать

---

## Логирование:

Все действия и ошибки записываются в `shell.log` в формате:

[2025-10-29 14:55:03] INFO: cd test

[2025-10-29 14:55:04] ERROR: Не существует указанного пути test
